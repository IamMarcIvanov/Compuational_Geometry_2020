//////////////////////////////////////////////////////////////////////
//
// BinarySearchTree.h: Need this tree for "event handling" during the
// make monotone function of the triangluation.
//
// I think I am going to use an AVL tree. Balanced and has O(log n) 
// search, insert and delete.
//
// Elements of the tree are edge nodes
//
// REVISIONS:
// Feb. 15, 2017 created (Alex Ashbourne)
//
//////////////////////////////////////////////////////////////////////

#pragma once

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#include <crtdbg.h>
#define DEBUG_NEW new(_NORMAL_BLOCK, __FILE__, __LINE__)
#define new DEBUG_NEW
#endif

#include<iostream>
#include <vector>
#include <algorithm>

#include "DblyConnectedEdgeList.h"

static const int ALLOWED_IMBALANCE = 1;

class EdgeNode
{
public:

	EdgeNode( HalfEdge* i_poElement ) : m_pElement(i_poElement), m_pLeftElement(0), m_pRightElement(0), m_pHelperVertex(i_poElement->getOrigin()), m_nHeight(0){}

	EdgeNode( HalfEdge* i_poElement, EdgeNode *i_poLeft, EdgeNode *i_poRight, int i_nHeight = 0)
	{
		//HalfEdge *m_pElement = new HalfEdge;
		m_pElement = i_poElement;
		m_pLeftElement = i_poLeft;
		m_pRightElement = i_poRight;
		m_pHelperVertex = i_poElement->getOrigin();
		m_nHeight = i_nHeight;
	}

	~EdgeNode()
	{
		//std::cout << "Edgenode delete \n" << std::endl;
	}

	EdgeNode(const EdgeNode &i_oRHSEdgeNode)
	{
		m_pElement = i_oRHSEdgeNode.m_pElement;
		m_pLeftElement = i_oRHSEdgeNode.m_pLeftElement;
		m_pRightElement = i_oRHSEdgeNode.m_pRightElement;
		m_pHelperVertex = i_oRHSEdgeNode.m_pHelperVertex;
	}

	EdgeNode &operator=(const EdgeNode &i_oRHSEdgeNode)
	{
		if(this != &i_oRHSEdgeNode)
		{
			m_pElement = i_oRHSEdgeNode.m_pElement;
			m_pLeftElement = i_oRHSEdgeNode.m_pLeftElement;
			m_pRightElement = i_oRHSEdgeNode.m_pRightElement;
			m_pHelperVertex = i_oRHSEdgeNode.m_pHelperVertex;
		};
		return *this;
	}

	bool operator==(const EdgeNode& i_oOtherEdgeNode)
	{
		return (*m_pElement == *(i_oOtherEdgeNode.m_pElement));
	}

	void setHelper(PolyVertex* i_oHelper){ m_pHelperVertex = i_oHelper; }

	PolyVertex* getHelper() { return m_pHelperVertex; }

	HalfEdge *m_pElement;
	EdgeNode *m_pLeftElement;
	EdgeNode *m_pRightElement;
	PolyVertex *m_pHelperVertex;
	int m_nHeight;
};

int Height(EdgeNode *i_poEdgeNode); 


class EdgeSearchTree
{
public:
	EdgeSearchTree(): m_pEdgeTreeRoot(0) {};

	~EdgeSearchTree()
	{
		//makeEmpty();
		//if(m_pEdgeTreeRoot != nullptr)
			//std::cout << "Search Tree delete \n" << std::endl;
	};

//////////////////////////////////////////////////////////////////////
//
// Public call to find most left edge
//
//////////////////////////////////////////////////////////////////////
	HalfEdge* FindMostLeft();

//////////////////////////////////////////////////////////////////////
//
// Public call to find node which is closest to the left of a vertex
//
//////////////////////////////////////////////////////////////////////
	EdgeNode* FindClosestLeft(PolyVertex *i_oPolyVertex);

//////////////////////////////////////////////////////////////////////
//
// Public call to insert a half edge
//
//////////////////////////////////////////////////////////////////////
	void InsertHalfEdge(HalfEdge* i_poHalfEdge);

//////////////////////////////////////////////////////////////////////
//
// Public call to remove a half edge
//
//////////////////////////////////////////////////////////////////////
	void RemoveHalfEdge(HalfEdge* i_poHalfEdge);

//////////////////////////////////////////////////////////////////////
//
// Public call to insert an edge node
//
//////////////////////////////////////////////////////////////////////
	void InsertEdgeNode(EdgeNode* i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Public call to remove an edge node
//
//////////////////////////////////////////////////////////////////////
	void RemoveEdgeNode(EdgeNode* i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Public call to find the edge node that holds a half edge
//
//////////////////////////////////////////////////////////////////////
	EdgeNode* FindEdgeNode(HalfEdge* i_poHalfEdge);

//////////////////////////////////////////////////////////////////////
//
// Boolean to check if empty
//
//////////////////////////////////////////////////////////////////////
	bool isEmpty() const;

//////////////////////////////////////////////////////////////////////
//
//  Public Call to empty the tree
//
//////////////////////////////////////////////////////////////////////
	void makeEmpty();

//////////////////////////////////////////////////////////////////////
//
// Rotation with left child for balancing
//
//////////////////////////////////////////////////////////////////////
	void rotateWithLeftChild(EdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Rotation with right child for balancing
//
//////////////////////////////////////////////////////////////////////
	void rotateWithRightChild(EdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Double Rotation with left child for balancing
//
//////////////////////////////////////////////////////////////////////
	void doubleWithLeftChild(EdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Double Rotation with left child for balancing
//
//////////////////////////////////////////////////////////////////////
	void doubleWithRightChild(EdgeNode *& i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Balance tree at given node
//
//////////////////////////////////////////////////////////////////////
	void BalanceTree(EdgeNode *& i_poEdgeNode);

private:

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively insert a half edge
//
//////////////////////////////////////////////////////////////////////
	void InsertHalfEdge(HalfEdge* i_poHalfEdge, EdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively remove a half edge
//
//////////////////////////////////////////////////////////////////////
	void RemoveHalfEdge(HalfEdge* i_poHalfEdge, EdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively insert an edge node
//
//////////////////////////////////////////////////////////////////////
	void InsertEdgeNode(EdgeNode* i_poNewEdgeNode, EdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to recursively remove an edge node
//
//////////////////////////////////////////////////////////////////////
	void RemoveEdgeNode(EdgeNode* i_poNewEdgeNode, EdgeNode *&i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to empty the tree recurrsively
//
//////////////////////////////////////////////////////////////////////
	void makeEmpty( EdgeNode* &i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private Recursive Function to return the edge node that holds a half edge
//
//////////////////////////////////////////////////////////////////////
	EdgeNode*FindEdgeNode(HalfEdge* i_poHalfEdge, EdgeNode* i_poEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to find most left edge
//
//////////////////////////////////////////////////////////////////////
	EdgeNode* FindMostLeft(EdgeNode *i_oEdgeNode);

//////////////////////////////////////////////////////////////////////
//
// Private call to closest edge to the left of a vertex
//
//////////////////////////////////////////////////////////////////////
	EdgeNode* FindClosestLeft(PolyVertex *i_oPolyVertex, EdgeNode *i_oEdgeNode);
	
//////////////////////////////////////////////////////////////////////
//
// Members of the search tree
//
//////////////////////////////////////////////////////////////////////
	EdgeNode *m_pEdgeTreeRoot; //root of tree
};